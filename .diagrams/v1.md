# Guía de Desarrollo Detallada: v1 - Generador de Wikis Estáticas

## Introducción

Esta guía detalla la implementación de un sistema server-side para generar wikis (documentaciones) estáticas desde repositorios Git. Es agnóstica al lenguaje: describe procesos, estructuras y lógica a nivel conceptual, adaptable a cualquier stack. Basada en métodos de DeepWiki-Open y Devin Deepwiki.

## Arquitectura General

- **Componentes**: API REST, sistema async (cola de tareas), BD relacional, integración IA local, comandos sistema.
- **Flujo Principal**: POST → Enqueue → Clonado → Análisis → Generación → Output static md files.

## Fase 1: Configuración Inicial y Diseño

**Objetivo**: Establecer base sólida sin implementación ejecutable.

### 1.1 Elección de Tecnologías y Herramientas

- Framework web: Sword (axum rust wrapper).
- IA local: vLLM (modelos por elejir).
- Sistema async: Librería para colas background (tokio::mpsc).
- Comandos sistema: Git, ripgrep.

### 1.2 Diseño de Arquitectura Modular

- **Capa API**: Endpoints, validación, responses.
- **Capa Lógica**: Procesamiento (clonado, análisis, generación).
- **Capa Datos**: Conexiones BD, queries.
- **Capa IA**: Prompts, llamadas a modelo.

### 1.4 Diseño de Prompts IA

- **Prompt Estructura**: "Analiza este JSON de árbol de archivos y contenido README. Genera JSON válido con 'sections' array. Cada section: 'name' string, 'pages' array. Cada page: 'title' string, 'files' array de paths, 'importance' string (high/medium/low)."
- **Prompt Contenido**: "Usa el contenido de estos archivos para generar markdown. Estructura: H1 título, H2 secciones, diagramas Mermaid en code blocks, tablas, snippets código, citas 'file.ext:line'. Contenido: [insertar texto archivos]."
- Estrategia: Prompts fijos, variables insertadas; validación respuesta JSON.

## Fase 2: Implementación del Núcleo

### 2.3 Procesamiento de Repositorio

- **Clonado**: Ejecutar comando Git clone --depth=1 en directorio temporal único; validar salida (código 0); cleanup en error.
- **Comando Tree**: Ejecutar tree -I 'node_modules|.git' -J; parsear JSON output; filtrar archivos > tamaño límite; almacenar en BD.
- **Generación Estructura**: Construir prompt con tree_json + README (leer del clon); enviar HTTP POST a IA; parsear JSON respuesta; validar estructura; almacenar sections.

### 2.4 Generación de Contenido

- Loop por páginas: Query pages*json; para cada file en page.files, leer del clon (encoding UTF-8, límite líneas); concatenar contenido; enviar prompt a IA; recibir markdown; escribir archivo output/repos/owner/repo-name/page*{index}.md.
- Optimizaciones: Procesar páginas secuencialmente para controlar uso IA; paralelizar lecturas archivos si pequeño repo.
- Validación: Markdown bien formado (headers, code blocks).
